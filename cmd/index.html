<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>smda</title>
    </head>
    <style type='text/css'>
        body, table {
            font-family: Arial, Helvetica, sans-serif;
            font-size: .9em;
        }
        header, footer {
            padding: 1em;
            background: #eee;
        }
        footer {
            text-align: right;
        }
        div#main {
            display: flex;
            min-height: calc(100% - 6.5em);
        }
        div#main nav#panel {
            width: 20%;
            padding: .5em;
            border-right: 1px dashed #eee;
        }
        div#main div#content {
            width: 80%;
            padding: 1em;
        }
    </style>
<body>
    <header>
        <span id='status'></span>

        <input id='filepicker' type='file' />
    </header>

    <div id='main'>
        <nav id='panel'>
            Explore:
            <div id='datasets'>
            </div>
        </nav>

        <div id='content'>
        </div>
    </div>

    <footer>
        <a href='https://github.com/kokes/smda'>github</a>
    </footer>
<script type='text/javascript'>
    class statusGetter {
        constructor(endpoint, target, minDuration, maxDuration) {
            this.endpoint = endpoint;
            this.target = target;
            this.minDuration = minDuration || 20;
            this.maxDuration = maxDuration || 30;
            this.duration = this.minDuration;
        }
        async checkStatus() {
            try {
                const status = await (await fetch(this.endpoint)).json();
                this.target.innerText = 'Status: ' + status.status;
                this.duration = this.minDuration; // reset if successful
            } catch (e) {
                this.target.innerText = 'Status: ' + e;
                // increase wait time unless it's larger than our maximum
                this.duration = Math.min(this.duration * 1.25, this.maxDuration);
            }
            setTimeout(this.checkStatus.bind(this), this.duration * 1000);
        }
    }

    async function init() {
        // check that our backend is live
        const sg = new statusGetter('/status', document.getElementById('status'));
        sg.checkStatus();

        // initiate a router that's based on hash changes
        window.onhashchange = function() {
            const hash = window.location.hash.slice(1).split('/');
            switch (hash[0]) {
                case 'explore':
                    setupExplore(hash[1])
                    break;
                default:
                    console.error(`unexpected route base: "${hash[0]}"`);
            }
        }
        // upon a page reload, there is no hashchange even triggered, so we need to fire it manually
        if (window.location.hash.length > 1) {
            window.dispatchEvent(new Event('hashchange'));
        }

        // link all the datasets we have
        const dss = document.getElementById('datasets');
        listDatasets(dss);
    }

    async function listDatasets(target) {
        const datasets = await (await fetch('/api/datasets')).json();
        const list = document.createElement('ul');

        for (const ds of (datasets || [])) {
            const dsli = document.createElement('li');
            const link = document.createElement('a');
            link.setAttribute('href', '#explore/' + ds.id);
            link.appendChild(document.createTextNode(`${ds.name} (${ds.id})`));
            dsli.appendChild(link);
            list.appendChild(dsli);
        }
        target.appendChild(list);
    }

    async function getDatasetData(datasetID) {
        const body = {
            limit: 25,
            dataset: datasetID,
            // aggregate: ['strings', 'bools'],
            // filter: 'floats> 12',
            // filter: 'strings = strings_null',
        }
        const req = await fetch('/api/query', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(body)
        })
        return await req.json();
    }

    function empty(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }

    async function setupExplore(datasetID) {
        const target = document.getElementById('content');
        empty(target);

        // TODO: render metadata as well
        renderTable(datasetID, target);
    }

    async function renderTable(datasetID, target) {
        const data = await getDatasetData(datasetID);
        const table = document.createElement('table');
        const thead = document.createElement('tr');
        for (let colname of data.columns) {
            const th = document.createElement('th');
            th.innerText = colname;
            thead.appendChild(th);
        }
        table.appendChild(thead);

        // this works, could only fail if we get zero columns, but that can't happen
        // might be more convenient/explicit if we send nrows from the backend
        const nrows = data.data[0].length;

        for (let rowNum=0; rowNum < nrows; rowNum++) {
            const row = document.createElement('tr');
            for (let colNum = 0; colNum < data.columns.length; colNum++) {
                const cell = document.createElement('td');
                cell.innerText = data.data[colNum][rowNum];
                row.appendChild(cell);
            }
            table.appendChild(row);
        }

        target.appendChild(table);
    }

    init();
</script>

</body>
</html>