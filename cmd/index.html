<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>smda</title>
    </head>
    <style type='text/css'>
        body, table {
            font-family: Arial, Helvetica, sans-serif;
            font-size: .9em;
        }
        header, footer {
            padding: 1em;
            background: #eee;
        }
        footer {
            text-align: right;
        }
        div#main {
            display: flex;
            min-height: calc(100% - 6.5em);
        }
        div#main nav#panel {
            width: 20%;
            padding: .5em;
            border-right: 1px dashed #eee;
        }
        div#main div#content {
            width: 80%;
            padding: 1em;
        }
        div.parsed-columns span {
            background-color: #7D7;
            border-radius: 4px;
            padding: .2em .5em;
            margin-right: .5em;
        }
        table.data-view {
            border-spacing: 0;
            margin-top: 1em;
            line-height: 1.5em;
        }
        table.data-view tr td {
            border-bottom: 1px solid #ccc;
            padding: .3em 1em .3em .3em;
        }
        table.data-view tr th {
            padding: .3em 1em .3em .3em;
            border: 1px solid #ccc;
            border-width: 1px 0;
        }
    </style>
<body>
    <header>
        <span id='status'></span>

        <input id='filepicker' type='file' />
    </header>

    <div id='main'>
        <nav id='panel'>
            Explore:
            <div id='datasets'>
            </div>
        </nav>

        <div id='content'>
        </div>
    </div>

    <footer>
        <a href='https://github.com/kokes/smda'>github</a>
    </footer>
<script type='text/javascript'>
    function split_expressions(s) {
        let nested = []; // stack
        let exprs = [];
        let current_expr = [];
        let idx = 0;
        while (true) {
            if (idx >= s.length) {
                break;
            }
            const char = s[idx];
            switch (char) {
                case ',':
                    if (nested.length === 0) {
                        exprs.push(current_expr.join(''));
                        current_expr = [];
                        idx++;
                        continue;
                    }
                    break;
                case ' ':
                    idx++;
                    continue;
                case '\n':
                    idx++;
                    continue;
                case '(':
                    nested.push(char);
                    break;
                case ')':
                    if (nested.pop() !== '(') {
                        throw Error('unexpected closing bracket')
                    }
                    break;
                // strings and identifiers (', ")
                case '\'':
                case '\"':
                    let j = 0;
                    nested.push(char); // this will force unclosed strings to result in remainders
                    for (j = idx + 1; j < s.length; j++) {
                        const ch = s[j];
                        if (ch === '\\') {
                            // TODO: what if this is the last char
                            j++; // escaped char means that the following char should be skipped too
                            continue;
                        }
                        if (ch === char) {
                            nested.pop();
                            break;
                        }
                    }
                    current_expr = current_expr.concat(s.slice(idx, j+1).split(''));
                    idx = j + 1; // include the end quote, but don't fall through to the `.push(char)` below
                    continue;
            }
            current_expr.push(char);
            idx++;
        }
        let remains = null;
        if (current_expr.length > 0) {
            // we'll have to modify this for onBlur (the last element)
            remains = current_expr.join('');
            // if (nested.length > 0) {
            // } else {
            //     exprs.push(current_expr.join(''));
            // }
        }
        return {
            expressions: exprs,
            remainder: remains,
            valid: nested.length === 0,
        };
    }

    // tests for split_expressions
    // console.log('result')
    // const inputs = [
    //     '',
    //     '"',
    //     '\'',
    //     'foo',
    //     'bar, baz',
    //     'sum("hello")',
    //     'sum("hello world")',
    //     '"hello ',
    //     'sum("hello, world"), nullif(baz, \'some ) string\')',
    //     'sum("hello world"), nullif(baz, \'some\\\' string\')',
    //     'foo, bar, baz, sum(bak),\n avg(nullif(foo, 3)), avg("BAU WAU"), sum(foo',
    // ]

    // for (let input of inputs) {
    //     console.log(split_expressions(input));
    // }

    class statusGetter {
        constructor(endpoint, target, minDuration, maxDuration) {
            this.endpoint = endpoint;
            this.target = target;
            this.minDuration = minDuration || 20;
            this.maxDuration = maxDuration || 30;
            this.duration = this.minDuration;
        }
        async checkStatus() {
            try {
                const status = await (await fetch(this.endpoint)).json();
                this.target.innerText = 'Status: ' + status.status;
                this.duration = this.minDuration; // reset if successful
            } catch (e) {
                this.target.innerText = 'Status: ' + e;
                // increase wait time unless it's larger than our maximum
                this.duration = Math.min(this.duration * 1.25, this.maxDuration);
            }
            setTimeout(this.checkStatus.bind(this), this.duration * 1000);
        }
    }

    function empty(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }

    // ARCH: this does a bit of UI stuff - maybe separate that out completely, so that
    // this becomes more testable
    class smda {
        constructor(remote) {
            this.remote = remote || window.location.origin;
            
            // check that our backend is live
            this.status = new statusGetter('/status', document.getElementById('status'));
            this.status.checkStatus();
            
            this.setupRouter();
            this.setupUI();
        }
        setupRouter() {
            const that = this;
            // initiate a router that's based on hash changes
            window.onhashchange = function() {
                const hash = window.location.hash.slice(1).split('/');
                switch (hash[0]) {
                    case 'explore':
                        that.setupExplore(hash[1])
                        break;
                    default:
                        console.error(`unexpected route base: "${hash[0]}"`);
                }
            }
            // upon a page reload, there is no hashchange even triggered, so we need to fire it manually
            if (window.location.hash.length > 1) {
                window.dispatchEvent(new Event('hashchange'));
            }
        }
        setupUI() {
            this.listDatasets(document.getElementById('datasets'));
        }
        async setupExplore(datasetID) {
            const target = document.getElementById('content');
            empty(target);

            // TODO: render metadata as well
            const data = await this.getDatasetData(datasetID);
            this.renderTable(data, target);
        }
        // OPTIM: perhaps abort if loaded in the past n miliseconds
        async loadDatasets() {
            const raw = await (await fetch('/api/datasets')).json();
            this.datasets = Object.fromEntries(raw.map(x => [x.id, x]))
        }
        async listDatasets(target) {
            empty(target);
            await this.loadDatasets();
            const list = document.createElement('ul');

            for (const [dsID, ds] of Object.entries(this.datasets || {})) {
                const dsli = document.createElement('li');
                const link = document.createElement('a');
                link.setAttribute('href', '#explore/' + dsID);
                link.appendChild(document.createTextNode(`${ds.name} (${dsID})`));
                dsli.appendChild(link);
                list.appendChild(dsli);
            }
            target.appendChild(list);
        }
        async getDatasetData(datasetID) {
            await this.loadDatasets();
            const columns = this.datasets[datasetID].schema.map(x=>x.name)
            const body = {
                select: ['strings', 'bools', 'min(ints)', 'min(ints_null)'],
                limit: 25,
                dataset: datasetID,
                aggregate: ['strings', 'bools'],
                // filter: 'floats != floats_null',
                // filter: 'strings = strings_null',
            }
            const req = await fetch('/api/query', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(body),
            })
            return await req.json();
        }

        // TODO: this is just a rendering thing - it doesn't extract any information out ¯\_(ツ)_/¯
        async renderTableSelection(target) {
            const container = document.createElement('div');
            const parsed_columns = document.createElement('div');
            parsed_columns.className = 'parsed-columns';

            container.appendChild(parsed_columns);

            const inp = document.createElement('input');
            inp.setAttribute('placeholder', 'select columns');
            const render_expressions = function(e) {
                if (e.target.value.trim().length === 0) {
                    return;
                }
                const exprs = split_expressions(e.target.value);
                const target = e.target.parentNode.querySelector('.parsed-columns');
                let to_render = exprs.expressions;
                // render remaining string when switching away or when hitting enter
                if (exprs.valid === true && (e.type === 'blur' || e.key == 'Enter')) {
                    to_render.push(exprs.remainder);
                    exprs.remainder = '';
                }
                // save these bits of information to send it to the backend
                for (let expr of to_render) {
                    const spex = document.createElement('span');
                    spex.innerText = expr;
                    target.appendChild(spex);
                }
                if (exprs.expressions.length > 0) {
                    e.target.value = exprs.remainder;
                }
            }
            inp.addEventListener('keyup', render_expressions);
            inp.addEventListener('blur', render_expressions);
            inp.addEventListener('change', render_expressions);

            container.appendChild(inp);
            target.appendChild(container);
        }
        async renderTable(data, target) {
            this.renderTableSelection(target);
            const table = document.createElement('table');
            table.className = "data-view";
            const thead = document.createElement('tr');
            for (let colname of data.columns) {
                const th = document.createElement('th');
                th.innerText = colname;
                thead.appendChild(th);
            }
            table.appendChild(thead);

            // this works, could only fail if we get zero columns, but that can't happen
            // might be more convenient/explicit if we send nrows from the backend
            const nrows = data.data[0].length;

            for (let rowNum=0; rowNum < nrows; rowNum++) {
                const row = document.createElement('tr');
                for (let colNum = 0; colNum < data.columns.length; colNum++) {
                    const cell = document.createElement('td');
                    cell.innerText = data.data[colNum][rowNum];
                    row.appendChild(cell);
                }
                table.appendChild(row);
            }

            target.appendChild(table);
        }
    }

    const db = new smda();
</script>

</body>
</html>