<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>smda</title>
    </head>
    <style type='text/css'>
        body {
            margin: 0; padding: 0;
        }
        body, table {
            font-family: Arial, Helvetica, sans-serif;
            font-size: .87em;
        }
        /* layout start */
        div#container {
            display: grid;
            height: 100vh;
            grid-template-columns: 250px auto;
            grid-template-rows: 3em auto 3em;
            /* this is also a feasible layout */
            /* grid-template-areas: "header header" "panel content" "footer footer"; */
            grid-template-areas: "panel header" "panel content" "panel footer";
        }
        header { grid-area: header; }
        nav#panel { grid-area: panel; }
        div#content { grid-area: content; }
        footer { grid-area: footer; }

        header, footer, nav#panel, div#content { padding: 1em; }

        /* we could use some fun colours, check out the generator over at https://coolors.co */
        header, footer {
            background-color: #eee;
        }
        footer {
            text-align: right;
            font-size: 90%;
        }
        nav#panel {
            background-color: #086375;
        }
        nav#panel, nav#panel a { color: #CCDBDC; }
        div#content {
            background-color: white;
        }
        /* end layout */
        table.data-view {
            border-spacing: 0;
            margin-top: 1em;
            line-height: 1.5em;
        }
        table.data-view tr td {
            border-bottom: 1px solid #ccc;
            padding: .3em 1em .3em .3em;
        }
        table.data-view tr th {
            padding: .3em 1em .3em .3em;
            border: 1px solid #ccc;
            border-width: 1px 0;
        }
    </style>
<body>
    <div id='container'>
        <header>
            <span id='status'></span>

            <input id='filepicker' type='file' multiple />
        </header>

        <nav id='panel'>
            Explore:
            <div id='datasets'>
            </div>
        </nav>

        <div id='content'>
        </div>

        <footer>
            <a href='https://github.com/kokes/smda'>github</a>
        </footer>
    </div>

<script type='text/javascript'>
    class statusGetter {
        constructor(endpoint, target, minDuration, maxDuration) {
            this.endpoint = endpoint;
            this.target = target;
            this.minDuration = minDuration || 20;
            this.maxDuration = maxDuration || 30;
            this.duration = this.minDuration;
        }
        async checkStatus() {
            try {
                const status = await (await fetch(this.endpoint)).json();
                this.target.innerText = 'Status: ' + status.status;
                this.duration = this.minDuration; // reset if successful
            } catch (e) {
                this.target.innerText = 'Status: ' + e;
                // increase wait time unless it's larger than our maximum
                this.duration = Math.min(this.duration * 1.25, this.maxDuration);
            }
            setTimeout(this.checkStatus.bind(this), this.duration * 1000);
        }
    }

    function empty(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }

    function node(tag, props, ...children) {
        const tg = document.createElement(tag);
        Object.keys(props || {}).forEach(k => tg.setAttribute(k, props[k]));
        children.forEach(child => tg.append(child))
        return tg;
    }

    // ARCH: this does a bit of UI stuff - maybe separate that out completely, so that
    // this becomes more testable
    class smda {
        constructor(remote) {
            this.remote = remote || window.location.origin;
            
            // check that our backend is live
            this.status = new statusGetter('/status', document.getElementById('status'));
            this.status.checkStatus();
            
            this.setupRouter();
            this.setupUI();
        }
        setupRouter() {
            const that = this;
            // initiate a router that's based on hash changes
            window.onhashchange = function() {
                const hash = window.location.hash.slice(1).split('/');
                switch (hash[0]) {
                    case 'explore':
                        that.setupExplore(hash[1])
                        break;
                    default:
                        console.error(`unexpected route base: "${hash[0]}"`);
                }
            }
            // upon a page reload, there is no hashchange even triggered, so we need to fire it manually
            if (window.location.hash.length > 1) {
                window.dispatchEvent(new Event('hashchange'));
            }
        }
        setupUI() {
            this.setupUploader()
            this.listDatasets(document.getElementById('datasets'));
        }
        setupUploader() {
            const fp = document.getElementById("filepicker");
            fp.addEventListener("change", async e => {
                e.target.disabled = "disabled";
                for (const file of e.target.files) {
                    const request = await fetch("/upload/auto", {
                        method: "POST",
                        body: file,
                    })
                    // TODO: err handling
                    const response = await request.json();
                }
                e.target.value = "";
                e.target.disabled = "";
                // TODO: refresh explore or do that implicitly via server side events?
            })
        }
        async setupExplore(datasetID) {
            const target = document.getElementById('content');

            // TODO: render metadata as well
            const data = await this.getDatasetData(datasetID);
            this.renderTable(data, target);
        }
        // OPTIM: perhaps abort if loaded in the past n miliseconds
        async loadDatasets() {
            const raw = await (await fetch('/api/datasets')).json();
            this.datasets = Object.fromEntries(raw.map(x => [x.id, x]))
        }
        async listDatasets(target) {
            await this.loadDatasets();

            const items = []
            for (const [dsID, ds] of Object.entries(this.datasets || {})) {
                const link = node("a", {href: `#explore/${dsID}`}, `${ds.name} (${dsID})`);
                const item = node("li", {}, link);
                items.push(item);
            }
            empty(target);
            target.appendChild(node("ul", {}, ...items));
        }
        async getDatasetData(datasetID) {
            await this.loadDatasets();
            const columns = this.datasets[datasetID].schema.map(x=>x.name)
            const body = {
                // always submit it as quoted if it's not all lowercase,
                // TODO: are there quotes in the individual names? can there be?
                select: columns.map(x => x.toLowerCase() === x ? x : `"${x}"`),
                limit: 25,
                dataset: datasetID,
                // aggregate: ['strings', 'bools'],
                // filter: 'floats != floats_null',
                // filter: 'strings = strings_null',
            }
            const req = await fetch('/api/query', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(body),
            })
            return await req.json();
        }
        async renderTable(data, target) {
            const table = node("table", {"class": "data-view"},
                node("thead", {},
                    node("tr", {}, ...data.schema.map((col) => node("th", {}, col.name)))
                )
            )

            // this works, could only fail if we get zero columns, but that can't happen
            // might be more convenient/explicit if we send nrows from the backend
            // TODO: send this as metadata
            const nrows = data.data[0].length;

            for (let rowNum=0; rowNum < nrows; rowNum++) {
                const row = node("tr", {},
                    ...data.schema.map((val, idx) => {
                        return node("td", {}, data.data[idx][rowNum])
                    })
                )
                table.appendChild(row);
                // ARCH: I think the imperative code below is more readable...
                // const row = document.createElement('tr');
                // for (let colNum = 0; colNum < data.schema.length; colNum++) {
                //     const cell = document.createElement('td');
                //     cell.innerText = data.data[colNum][rowNum];
                //     row.appendChild(cell);
                // }
                // table.appendChild(row);
            }

            empty(target);
            target.appendChild(table);
        }
    }

    const db = new smda();
</script>

</body>
</html>