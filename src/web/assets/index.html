<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>smda</title>
    </head>
    <style type='text/css'>
        * {
            margin: 0; padding: 0;
        }
        body, table {
            font-family: Arial, Helvetica, sans-serif;
        }
        div#errors {
            position: absolute;
            left: 50%; top: 10%;
            margin-left: -200px;
            width: 400px;
        }
        div#errors > div {
            padding: 1em;
            margin-bottom: .5em;
            width: 100%;
            border: 1px solid red;
            background: lightpink;
            color: darkred;
        }
        /* layout start */
        div#container {
            display: grid;
            height: 100vh;
            grid-template-columns: 250px auto;
            grid-template-rows: 3em auto 3em;
            /* this is also a feasible layout */
            /* grid-template-areas: "header header" "panel content" "footer footer"; */
            grid-template-areas: "panel header" "panel content" "panel footer";
        }
        header { grid-area: header; }
        nav#panel { grid-area: panel; }
        main {
            grid-area: content;
            /*
                I want to limit it in width (so that we can scroll its children elements... but what's the best way?)
                max-width: calc(100vw - 250px - 3em);
            */
        }
        footer { grid-area: footer; }

        header, footer, main { padding: 1em; }

        /* we could use some fun colours, check out the generator over at https://coolors.co */
        header, footer {
            display: flex;
            flex-direction: row;
            background-color: #eee;
            align-items: center;
        }
        header {
            justify-content: space-between;
        }
        footer {
            justify-content: flex-end;
            font-size: 90%;
        }
        nav#panel {
            background-color: #086375;
        }
        nav#panel, nav#panel a { color: #CCDBDC; }
        main {
            background-color: white;
            overflow: auto;
        }
        main > div {
            /* prevent flickering upon load */
            display: none;
        }
        /* end layout */
        div#status {
            height: 2em;
            width: 2em;
        }
        div#status svg { height: 100%; width: 100%; display: none; }
        svg#status-ok { color: green; }
        svg#status-nok { color: red; }

        table {
            border-spacing: 0;
            margin-top: 1em;
            line-height: 1.5em;
        }
        table tr:nth-child(even) {
            background: lavenderblush;
        }
        table tr td, table tr th {
            padding: .5em 1em;
            /*
              this is primarily for extendable tables (e.g. schema overviews), so that
              the content doesn't jump around
            */
            vertical-align: top;
        }
        table tr td summary:hover {
            cursor: pointer;
        }
        table tr th {
            border-bottom: 2px solid mistyrose;
        }

        nav#panel ul li {
            list-style: none;
        }
        nav#panel ul li a {
            display: block;
            padding: 1em;
            text-decoration: underline;
        }
        nav#panel ul li a:hover, nav#panel ul li a.current {
            background: darkslategray;
        }

        form fieldset {
            padding: 1em;
            border: 1px solid #ccc;
        }
        form fieldset legend {
            padding: .5em;
            border: 1px solid darkslategray;
            background: #eee;
        }
        form fieldset > div {
            margin: .7em 0;
            display: flex;
            flex-direction: row;
            align-items: center;
        }
        form fieldset > div label {
            display: block;
            width: 150px;
            padding-right: 1em;
        }
        form fieldset > div input {
            padding: .3em .5em;
            min-width: 600px;
            max-width: 80%;
        }
        form fieldset button {
            padding: .3em 1em;
        }

        form small#elapsed {
            padding-left: 1em;
        }

        div#query-results {
            /* width: calc(100vw - 250px); */
            /*
                this would make the horizontal scrollbar unreachable for long tables... that's kinda impractical
                overflow-x: scroll;
            */
        }
    </style>
<body>
    <div id="errors"></div>
    <div id='container'>
        <header>
            <input id='filepicker' type='file' multiple />

            <div id='status'>
                <!-- bootstrap icons: cloud-check, cloud-slash-->
                <!-- TODO: click these to open a window with server info (resources, latencies etc.) -->
                <svg id="status-ok" xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-cloud-check" viewBox="0 0 16 16">
                    <title>Connected to a server</title>
                    <path fill-rule="evenodd" d="M10.354 6.146a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 1 1 .708-.708L7 8.793l2.646-2.647a.5.5 0 0 1 .708 0z"/>
                    <path d="M4.406 3.342A5.53 5.53 0 0 1 8 2c2.69 0 4.923 2 5.166 4.579C14.758 6.804 16 8.137 16 9.773 16 11.569 14.502 13 12.687 13H3.781C1.708 13 0 11.366 0 9.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383zm.653.757c-.757.653-1.153 1.44-1.153 2.056v.448l-.445.049C2.064 6.805 1 7.952 1 9.318 1 10.785 2.23 12 3.781 12h8.906C13.98 12 15 10.988 15 9.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 4.825 10.328 3 8 3a4.53 4.53 0 0 0-2.941 1.1z"/>
                </svg>

                <svg id="status-nok" xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-cloud-slash" viewBox="0 0 16 16">
                    <title>Disconnected from a server</title>
                    <path fill-rule="evenodd" d="M3.112 5.112a3.125 3.125 0 0 0-.17.613C1.266 6.095 0 7.555 0 9.318 0 11.366 1.708 13 3.781 13H11l-1-1H3.781C2.231 12 1 10.785 1 9.318c0-1.365 1.064-2.513 2.46-2.666l.446-.05v-.447c0-.075.006-.152.018-.231l-.812-.812zm2.55-1.45l-.725-.725A5.512 5.512 0 0 1 8 2c2.69 0 4.923 2 5.166 4.579C14.758 6.804 16 8.137 16 9.773a3.2 3.2 0 0 1-1.516 2.711l-.733-.733C14.498 11.378 15 10.626 15 9.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 4.825 10.328 3 8 3c-.875 0-1.678.26-2.339.661z"/>
                    <path d="M13.646 14.354l-12-12 .708-.708 12 12-.707.707z"/>
                </svg>
            </div>
        </header>

        <nav id='panel'>
            <ul>
                <li><a href='/query'>Query</a></li>
                <li><a href='/datasets'>Datasets</a></li>
            </ul>
        </nav>

        <main>
            <div id="route-datasets"></div>
            <div id="route-query">
                <form action="/query" name="query">
                    <fieldset>
                        <legend>Query parameters</legend>
                        <div>
                            <label for="dataset">Dataset</label>
                            <input id="dataset" name="dataset" placeholder="orders" />
                        </div>
                        <div>
                            <label for="filter">Filter</label>
                            <input name="filter" id="filter" placeholder="customer_id = 123 AND status = 'Done'"/>
                        </div>
                        <div>
                            <label for="aggregate">Aggregate</label>
                            <input name="aggregate" id="aggregate" placeholder="region, division" />
                        </div>
                        <div>
                            <label for="select">Select</label>
                            <input name="select" id="select" placeholder="region, division, count(), sum(revenue)" />
                        </div>
                        <div>
                            <label for="order">Order</label>
                            <input name="order" id="order" placeholder="sum(revenue) DESC" />
                        </div>
                        <div>
                            <label for="limit">Limit</label>
                            <input name="limit" id="limit" type="number" placeholder="100" />
                        </div>

                        <button>Run query</button>
                        <small id="elapsed"></small>
                    </fieldset>
                </form>

                <div id="query-results"></div>
            </div>
        </main>

        <footer>
            <a href='https://github.com/kokes/smda'>github</a>
        </footer>
    </div>

<script type='text/javascript'>
    class statusGetter {
        constructor(endpoint, target, minDuration, maxDuration) {
            this.endpoint = endpoint;
            this.minDuration = minDuration || 5;
            this.maxDuration = maxDuration || 15;
            this.duration = this.minDuration;
        }
        async checkStatus() {
            let ok = true;
            try {
                const status = await (await fetch(this.endpoint)).json();
                this.duration = this.minDuration; // reset if successful
            } catch (e) {
                ok = false;
                // increase wait time unless it's larger than our maximum
                this.duration = Math.min(this.duration * 1.25, this.maxDuration);
            }
            document.getElementById("status-ok").style.display = ok ? "block" : "none";
            document.getElementById("status-nok").style.display = ok ? "none": "block";
            setTimeout(this.checkStatus.bind(this), this.duration * 1000);
        }
    }

    function empty(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }

    document.addEventListener("keydown", e => {
        if (e.code != "Escape") {
            return;
        }
        for (let dv of document.querySelectorAll("div#errors div")) {
            dv.remove();
        }
    })
    function errDialog(title, msg) {
        const target = document.getElementById("errors");
        target.setAttribute("title", "click to dismiss");
        const name = node("h3", null, title);
        const err = node("div", null, [name, msg]);
        err.addEventListener("click", e => {
            e.target.closest("div").remove();
        });
        target.append(err);
    }

    function node(tag, props, children) {
        const tg = document.createElement(tag);
        Object.keys(props || {}).forEach(k => tg.setAttribute(k, props[k]));
        if (Array.isArray(children)) {
            children.forEach(child => tg.append(child));
        } else {
            tg.append(children);
        }
        return tg;
    }

    // TODO: test (0, 999, 1001, trailing zeroes etc.)
    function formatBytes(nbytes) {
        if (nbytes === 0) {
            return "0 B"
        }
        const units = ["B", "KB", "MB", "GB", "TB", "PB"]; // that should be enough :-)
        const scale = Math.floor(Math.log10(nbytes)/3);
        let fixed = (nbytes/Math.pow(10, 3*scale)).toFixed(2);
        if (fixed.endsWith(".00")) {
            fixed = fixed.slice(0, fixed.length - 3);
        }

        return `${fixed} ${units[scale]}`;
    }

    // TODO: test (0, 1, 59/60 seconds etc., test fallbacks, test future)
    function formatTimestamp(timestamp_s) {
        const now = Math.floor((new Date()).getTime()/1000);
        const diff = Math.floor(now - timestamp_s); // timestamp_s can be a float (and now is)
        // ARCH: change from if statements to some for loop with decreasing granularity
        // also handle plurals betters
        if (diff < 0) {
            // future timestamps are tricky (clocks can get skewed) - also, even if we sent server time
            // as some guideline... we could still get a skew (not as bad as local time though)
            return (new Date(timestamp_s * 1000).toISOString());
        }
        if (diff < 60) {
            return `${diff} seconds ago`;
        }
        if (diff < 3600) {
            return `${Math.floor(diff/60)} minutes ago`;
        }
        if (diff < 3600*24) {
            return `${Math.floor(diff/3600)} hours ago`;
        }
        if (diff < 3600*24*30) {
            return `${Math.floor(diff/3600/24)} days ago`;
        }
        if (diff < 3600*24*365) {
            return `${Math.floor(diff/3600/24/30)} months ago`;
        }
        return `${Math.floor(diff/3600/24/30)} years ago`;
        // ARCH: should the fallback be years or ISO date?
        // return (new Date(timestamp * 1000).toISOString());
    }

    function formatDuration(ms, prefix) {
        if (ms < 1000) {
            return `${prefix} ${Math.round(ms)} ms`;
        }
        return `${prefix} ${(ms/1000).toFixed(2)} seconds`;
    }

    // ARCH: this does a bit of UI stuff - maybe separate that out completely, so that
    // this becomes more testable
    class smda {
        constructor(remote) {
            this.remote = remote || window.location.origin;
            
            // check that our backend is live
            this.status = new statusGetter('/status');
            this.status.checkStatus();
            
            this.setupRouter();
            this.setupUI();
        }
        setupRouter() {
            const that = this;

            const currentClass = "current";
            for (let link of document.querySelectorAll("nav#panel ul li a")) {
                if (link.classList.contains(currentClass)) {
                    link.classList.remove(currentClass);
                }
                if (link.getAttribute("href") === window.location.pathname) {
                    link.classList.add(currentClass);
                }
            }

            const qform = document.forms["query"];
            if (qform !== undefined) {
                const params = new URLSearchParams(window.location.search);
                for (let inp of qform.querySelectorAll("input, select")) {
                    const fieldName = inp.getAttribute("name");
                    inp.value = params.get(fieldName);
                }
            }

            const path = window.location.pathname.slice(1).split("/");
            document.querySelectorAll("main > div").forEach(x => x.style.display = "none");
            // ARCH: pass this down to submitQuery/setupDatasets?
            const target = document.getElementById(`route-${path[0]}`);
            if (target !== null) {
                target.style.display = "block";
            }

            switch (path[0]) {
                case '':
                    // TODO(next): do something for the homepage
                    break
                case 'query':
                    that.submitQuery(); // ARCH: automatic submission, maybe too eager?
                    break;
                case 'datasets':
                    that.setupDatasets();
                    break;
                default:
                    console.error(`unexpected route base: "${path[0]}"`);
            }
        }
        setupUI() {
            this.setupUploader()
        }
        setupUploader() {
            const fp = document.getElementById("filepicker");
            fp.addEventListener("change", async e => {
                e.target.disabled = "disabled";
                for (const file of e.target.files) {
                    const filename = encodeURIComponent(file.name);
                    try {
                        const request = await fetch(`/upload/auto?name=${filename}`, {
                            method: "POST",
                            body: file,
                        })
                        const response = await request.json();
                    } catch (e) {
                        errDialog(`failed to upload ${file.name}`, e);
                    }
                }
                e.target.value = "";
                e.target.disabled = "";
            })
        }
        async submitQuery() {
            const qform = document.forms["query"];
            const target = document.getElementById("query-results");
            const elapsed = qform.querySelector("small#elapsed");
            // if nothing is to be submitted, just remove any leftover query results and exit
            if (qform.dataset.value === "") {
                empty(elapsed);
                empty(target);
                return;
            }

            const valueparts = qform.dataset.value.split("@v");
            const query = {
                dataset: {
                    name: valueparts[0],
                    id: valueparts[1], // ARCH: might be `version`
                },
            };
            let data, incrementor, startTime, success = false;
            try {
                if (qform.filter.value !== "") {
                    query.filter = qform.filter.value;
                }
                if (qform.aggregate.value !== "") {
                    query.aggregate = qform.aggregate.value;
                }
                if (qform.select.value !== "") {
                    query.select = qform.select.value;
                }
                if (qform.order.value !== "") {
                    query.order = qform.order.value;
                }
                if (qform.limit.value !== "") {
                    query.limit = parseInt(qform.limit.value, 10);
                }

                startTime = performance.now();
                incrementor = setInterval(() => {
                    elapsed.textContent = formatDuration(performance.now() - startTime, "Elapsed: ");
                }, 100)

                data = await this.runQuery(query);
                success = true;
            } catch(e) {
                errDialog("Failed to run query", e)
            } finally {
                clearInterval(incrementor);
                elapsed.textContent = formatDuration(performance.now() - startTime, "Elapsed: ");
            }

            if (success) {
                empty(target);
                this.renderTable(data, target);
            }

        }
        async setupDatasets() {
            const target = document.getElementById('route-datasets');

            // OPTIM: well, this is uncached in multiple places
            await this.loadDatasets();
            const header = node("thead", {}, node("tr", null, ["Identifier", "Name", "Created Time", "Size (original)", "Size on disk", "Number of rows", "Table schema"].map(
                column => node("th", null, column)
            )));
            const datasets = Object.values(this.datasets);
            datasets.sort((a, b) => b.created_timestamp - a.created_timestamp)
            const rows = node("tbody", null, datasets.map(
                ds => {
                    const dsv = encodeURIComponent(`${ds.name}@v${ds.id}`);
                    const cols = [
                        node("td", null, node("a", {"href": `/query?dataset=${dsv}&limit=100`}, ds.id)),
                        node("td", null, ds.name),
                        node("td", null,
                            node("span",
                                {"title": (new Date(ds.created_timestamp / 1000 / 1000).toISOString())},
                                formatTimestamp(ds.created_timestamp / 1000 / 1000 / 1000)
                                )
                            ),
                        node("td", null, formatBytes(ds.size_raw)),
                        node("td", null, formatBytes(ds.size_on_disk)),
                        node("td", null, ds.nrows.toLocaleString()),
                        node("td", null, node("details", {},
                        [
                            node("summary", {}, `${ds.schema.length} columns`),
                            node("ul", {}, ds.schema.map(
                                col => node("li", {}, `${col.name} (${col.dtype})`)
                            ))
                        ])),
                    ]
                    return node("tr", null, cols);
                }
            ));
            const overview = node("table", {"id": "datasets"}, [header, rows]);

            empty(target);
            target.append(overview);
        }
        // OPTIM: perhaps abort if loaded in the past n miliseconds
        async loadDatasets() {
            const raw = await (await fetch('/api/datasets')).json();
            this.datasets = Object.fromEntries(raw.map(x => [x.id, x]))
        }
        async runQuery(query) {
            if (query["select"] === undefined) {
                query["select"] = "*";
            }
            if (query["limit"] === undefined) {
                query["limit"] = 100; // ARCH: safety mechanism
            }
            const req = await fetch('/api/query', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(query),
            })
            if (req.ok === false) {
                const error = await req.text();
                throw new Error(error);
            }
            return await req.json();
        }
        async renderTable(data, target) {
            const table = node("table", {"class": "data-view"},
                node("thead", {},
                    node("tr", {}, data.schema.map((col) => node("th", {}, col.name)))
                )
            )

            for (let rowNum=0; rowNum < data.nrows; rowNum++) {
                const rowData = data.data[rowNum];
                const row = node("tr", {},
                    data.schema.map((val, idx) => {
                        return node("td", {}, rowData[idx])
                    })
                )
                table.appendChild(row);
                // ARCH: I think the imperative code below is more readable...
                // const row = document.createElement('tr');
                // for (let colNum = 0; colNum < data.schema.length; colNum++) {
                //     const cell = document.createElement('td');
                //     cell.innerText = data.data[colNum][rowNum];
                //     row.appendChild(cell);
                // }
                // table.appendChild(row);
            }

            empty(target);
            target.appendChild(table);
        }
    }

    const db = new smda();
    // further router setup
    document.addEventListener("click", e => {
        // ARCH: input[type=submit]?
        if (!(e.target.nodeName === "BUTTON" || e.target.nodeName === "A")) {
            return;
        }
        e.preventDefault();

        switch (e.target.nodeName) {
            case "A":
                const link = e.target.getAttribute("href");
                history.pushState({}, "", link);
                break;
            case "BUTTON":
                const url = new URL(window.location);
                url.search = '';
                const qform = e.target.closest("form");
                if (qform.method !== "get") {
                    throw new Error("cannot submit POST forms yet");
                }
                for (let entry of (new FormData(qform)).entries()) {
                    url.searchParams.set(entry[0], entry[1]);
                }
                history.pushState({}, "", url);
                break;
        }

        db.setupRouter();
    });
    window.onpopstate = e => {
        db.setupRouter();
    }
</script>

</body>
</html>
