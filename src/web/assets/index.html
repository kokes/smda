<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>smda</title>
    </head>
    <style type='text/css'>
        * {
            margin: 0; padding: 0;
        }
        body, table {
            font-family: Arial, Helvetica, sans-serif;
            font-size: .87em;
        }
        /* layout start */
        div#container {
            display: grid;
            height: 100vh;
            grid-template-columns: 250px auto;
            grid-template-rows: 3em auto 3em;
            /* this is also a feasible layout */
            /* grid-template-areas: "header header" "panel content" "footer footer"; */
            grid-template-areas: "panel header" "panel content" "panel footer";
        }
        header { grid-area: header; }
        nav#panel { grid-area: panel; }
        div#content {
            grid-area: content;
            /*
                I want to limit it in width (so that we can scroll its children elements... but what's the best way?)
                max-width: calc(100vw - 250px - 3em);
            */
        }
        footer { grid-area: footer; }

        header, footer, div#content { padding: 1em; }

        /* we could use some fun colours, check out the generator over at https://coolors.co */
        header, footer {
            display: flex;
            flex-direction: row;
            background-color: #eee;
            align-items: center;
        }
        header {
            justify-content: space-between;
        }
        footer {
            justify-content: flex-end;
            font-size: 90%;
        }
        nav#panel {
            background-color: #086375;
        }
        nav#panel, nav#panel a { color: #CCDBDC; }
        div#content {
            background-color: white;
            /* overflow-x: scroll; */
        }
        /* end layout */
        div#status {
            height: 2em;
            width: 2em;
        }
        div#status svg { height: 100%; width: 100%; display: none; }
        svg#status-ok { color: green; }
        svg#status-nok { color: red; }

        table {
            border-spacing: 0;
            margin-top: 1em;
            line-height: 1.5em;
        }
        table tr:nth-child(even) {
            background: #eee;
        }
        table tr td, table tr th {
            padding: .5em 1em;
            /*
              this is primarily for extendable tables (e.g. schema overviews), so that
              the content doesn't jump around
            */
            vertical-align: top;
        }
        table tr td summary:hover {
            cursor: pointer;
        }
        table tr th {
            border-bottom: 2px solid #ccc;
        }

        nav#panel ul li {
            list-style: none;
        }
        nav#panel ul li a {
            display: block;
            padding: 1em;
            text-decoration: underline;
        }
        nav#panel ul li a:hover, nav#panel ul li a.current {
            background: darkslategray;
        }

        form fieldset {
            padding: 1em;
            border: 1px solid #ccc;
        }
        form fieldset legend {
            padding: .5em;
            border: 1px solid darkslategray;
            background: #eee;
        }
        form fieldset > div {
            margin: .7em 0;
            display: flex;
            flex-direction: row;
            align-items: center;
        }
        form fieldset > div label {
            display: block;
            width: 150px;
            padding-right: 1em;
        }
        form fieldset > div input {
            padding: .3em .5em;
            min-width: 500px;
            max-width: 80%;
        }
        form fieldset button {
            padding: .3em 1em;
        }

        div#query-results {
            /* width: calc(100vw - 250px); */
            /*
                this would make the horizontal scrollbar unreachable for long tables... that's kinda impractical
                overflow-x: scroll;
            */
        }
    </style>
<body>
    <div id='container'>
        <header>
            <input id='filepicker' type='file' multiple />

            <div id='status'>
                <!-- bootstrap icons: cloud-check, cloud-slash-->
                <!-- TODO: click these to open a window with server info (resources, latencies etc.) -->
                <svg id="status-ok" xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-cloud-check" viewBox="0 0 16 16">
                    <title>Connected to a server</title>
                    <path fill-rule="evenodd" d="M10.354 6.146a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 1 1 .708-.708L7 8.793l2.646-2.647a.5.5 0 0 1 .708 0z"/>
                    <path d="M4.406 3.342A5.53 5.53 0 0 1 8 2c2.69 0 4.923 2 5.166 4.579C14.758 6.804 16 8.137 16 9.773 16 11.569 14.502 13 12.687 13H3.781C1.708 13 0 11.366 0 9.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383zm.653.757c-.757.653-1.153 1.44-1.153 2.056v.448l-.445.049C2.064 6.805 1 7.952 1 9.318 1 10.785 2.23 12 3.781 12h8.906C13.98 12 15 10.988 15 9.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 4.825 10.328 3 8 3a4.53 4.53 0 0 0-2.941 1.1z"/>
                </svg>

                <svg id="status-nok" xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-cloud-slash" viewBox="0 0 16 16">
                    <title>Disconnected from a server</title>
                    <path fill-rule="evenodd" d="M3.112 5.112a3.125 3.125 0 0 0-.17.613C1.266 6.095 0 7.555 0 9.318 0 11.366 1.708 13 3.781 13H11l-1-1H3.781C2.231 12 1 10.785 1 9.318c0-1.365 1.064-2.513 2.46-2.666l.446-.05v-.447c0-.075.006-.152.018-.231l-.812-.812zm2.55-1.45l-.725-.725A5.512 5.512 0 0 1 8 2c2.69 0 4.923 2 5.166 4.579C14.758 6.804 16 8.137 16 9.773a3.2 3.2 0 0 1-1.516 2.711l-.733-.733C14.498 11.378 15 10.626 15 9.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 4.825 10.328 3 8 3c-.875 0-1.678.26-2.339.661z"/>
                    <path d="M13.646 14.354l-12-12 .708-.708 12 12-.707.707z"/>
                </svg>
            </div>
        </header>

        <nav id='panel'>
            <ul>
                <li><a href='/query'>Query</a></li>
                <li><a href='/datasets'>Datasets</a></li>
            </ul>
        </nav>

        <div id='content'>
            <form action="/query" name="query">
                <fieldset>
                    <legend>Query parameters</legend>
                    <!--
                        TODO(next):
                         - input placeholders
                         - proper support for multiple select/aggregate expressions
                         - show names in the dataset dropdown (and allow for autocomplete?)
                     -->
                    <div>
                        <label for="dataset_id">Dataset</label>
                        <input name="dataset" id="dataset_id" />
                    </div>
                    <div>
                        <label for="filter">Filter</label>
                        <input name="filter" id="filter" />
                    </div>
                    <div>
                        <label for="aggregate">Aggregate</label>
                        <input name="aggregate" id="aggregate" />
                    </div>
                    <div>
                        <label for="select">Select</label>
                        <input name="select" id="select" />
                    </div>
                    <div>
                        <label for="limit">Limit</label>
                        <input name="limit" id="limit" type="number" />
                    </div>

                    <button>Run query</button>
                </fieldset>
            </form>

            <div id="query-results"></div>
        </div>

        <footer>
            <a href='https://github.com/kokes/smda'>github</a>
        </footer>
    </div>

<script type='text/javascript'>
    class statusGetter {
        constructor(endpoint, target, minDuration, maxDuration) {
            this.endpoint = endpoint;
            this.minDuration = minDuration || 5;
            this.maxDuration = maxDuration || 15;
            this.duration = this.minDuration;
        }
        async checkStatus() {
            let ok = true;
            try {
                const status = await (await fetch(this.endpoint)).json();
                this.duration = this.minDuration; // reset if successful
            } catch (e) {
                ok = false;
                // increase wait time unless it's larger than our maximum
                this.duration = Math.min(this.duration * 1.25, this.maxDuration);
            }
            document.getElementById("status-ok").style.display = ok ? "block" : "none";
            document.getElementById("status-nok").style.display = ok ? "none": "block";
            setTimeout(this.checkStatus.bind(this), this.duration * 1000);
        }
    }

    function empty(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }

    function node(tag, props, ...children) {
        const tg = document.createElement(tag);
        Object.keys(props || {}).forEach(k => tg.setAttribute(k, props[k]));
        children.forEach(child => tg.append(child))
        return tg;
    }

    // TODO: test (0, 999, 1001, trailing zeroes etc.)
    function formatBytes(nbytes) {
        if (nbytes === 0) {
            return "0 B"
        }
        const units = ["B", "KB", "MB", "GB", "TB", "PB"]; // that should be enough :-)
        const scale = Math.floor(Math.log10(nbytes)/3);
        let fixed = (nbytes/Math.pow(10, 3*scale)).toFixed(2);
        if (fixed.endsWith(".00")) {
            fixed = fixed.slice(0, fixed.length - 3);
        }

        return `${fixed} ${units[scale]}`;
    }

    // TODO: test (0, 1, 59/60 seconds etc., test fallbacks, test future)
    function formatTimestamp(timestamp) {
        const now = Math.floor((new Date()).getTime()/1000);
        const diff = now - timestamp;
        // ARCH: change from if statements to some for loop with decreasing granularity
        // also handle plurals betters
        if (diff < 0) {
            // future timestamps are tricky (clocks can get skewed) - also, even if we sent server time
            // as some guideline... we could still get a skew (not as bad as local time though)
            return (new Date(timestamp * 1000).toISOString());
        }
        if (diff < 60) {
            return `${diff} seconds ago`;
        }
        if (diff < 3600) {
            return `${Math.floor(diff/60)} minutes ago`;
        }
        if (diff < 3600*24) {
            return `${Math.floor(diff/3600)} hours ago`;
        }
        if (diff < 3600*24*30) {
            return `${Math.floor(diff/3600/24)} days ago`;
        }
        if (diff < 3600*24*365) {
            return `${Math.floor(diff/3600/24/30)} months ago`;
        }
        return `${Math.floor(diff/3600/24/30)} years ago`;
        // ARCH: should the fallback be years or ISO date?
        // return (new Date(timestamp * 1000).toISOString());
    }

    // ARCH: this does a bit of UI stuff - maybe separate that out completely, so that
    // this becomes more testable
    class smda {
        constructor(remote) {
            this.remote = remote || window.location.origin;
            
            // check that our backend is live
            this.status = new statusGetter('/status');
            this.status.checkStatus();
            
            this.setupRouter();
            this.setupUI();
        }
        // TODO/ARCH: we could preventDefault on all links and use the History API to handle everything
        // on the client since most links will be served by index.html anyway
        // Probably by addEventListener to all `a`s and then using MutationObserver to monitor new links and buttons
        setupRouter() {
            const that = this;

            const path = window.location.pathname.slice(1).split("/");
            switch (path[0]) {
                case 'query':
                    that.setupQuery()
                    break;
                case 'datasets':
                    that.setupDatasets();
                    break;
                default:
                    console.error(`unexpected route base: "${path[0]}"`);
            }

            const currentClass = "current";
            for (let link of document.querySelectorAll("nav#panel ul li a")) {
                if (link.classList.contains(currentClass)) {
                    link.classList.remove(currentClass);
                }
                if (link.getAttribute("href") === window.location.pathname) {
                    link.classList.add(currentClass);
                }
            }
        }
        setupUI() {
            this.setupUploader()
        }
        setupUploader() {
            const fp = document.getElementById("filepicker");
            fp.addEventListener("change", async e => {
                e.target.disabled = "disabled";
                for (const file of e.target.files) {
                    const filename = encodeURIComponent(file.name);
                    const request = await fetch(`/upload/auto?name=${filename}`, {
                        method: "POST",
                        body: file,
                    })
                    // TODO: err handling
                    const response = await request.json();
                }
                e.target.value = "";
                e.target.disabled = "";
            })
        }
        async setupQuery() {
            const qform = document.forms["query"];
            const params = new URLSearchParams(window.location.search);
            for (let inp of qform.querySelectorAll("input")) {
                const fieldName = inp.getAttribute("name");
                inp.value = params.get(fieldName);
            }

            const target = document.getElementById("query-results");
            const query = {
                dataset: qform.dataset.value,
            };
            if (qform.filter.value !== "") {
                query.filter = qform.filter.value;
            }
            if (qform.aggregate.value != "") {
                query.aggregate = qform.aggregate.value.split(","); // TODO(next): support multiple aggregation expressions
            }
            if (qform.select.value != "") {
                query.select = qform.select.value.split(","); // TODO(next): support multiple selection expressions
            }
            if (qform.limit.value !== "") {
                query.limit = parseInt(qform.limit.value, 10);
            }
            const data = await this.runQuery(query);
            this.renderTable(data, target);

        }
        async setupDatasets() {
            const target = document.getElementById('content');

            // OPTIM: well, this is uncached in multiple places
            await this.loadDatasets();
            // TODO(next): remove all this elipsis handling and make it accept arrays
            const header = node("thead", {}, node("tr", null, ...["Identifier", "Name", "Created Time", "Size (original)", "Size on disk", "Number of rows", "Table schema"].map(
                column => node("th", null, column)
            )));
            const datasets = Object.values(this.datasets);
            datasets.sort((a, b) => b.created_timestamp - a.created_timestamp)
            const rows = node("tbody", null, ...datasets.map(
                ds => {
                    const cols = [
                        node("td", null, node("a", {"href": `/query?dataset=${ds.id}&limit=100`}, ds.id)),
                        node("td", null, ds.name),
                        node("td", null,
                            node("span",
                                {"title": (new Date(ds.created_timestamp * 1000).toISOString())},
                                formatTimestamp(ds.created_timestamp)
                                )
                            ),
                        node("td", null, formatBytes(ds.size_raw)),
                        node("td", null, formatBytes(ds.size_on_disk)),
                        node("td", null, ds.nrows.toLocaleString()),
                        node("td", null, node("details", {},
                            node("summary", {}, `${ds.schema.length} columns`),
                            node("ul", {}, ...ds.schema.map(
                                col => node("li", {}, `${col.name} (${col.dtype})`)
                            ))
                        )),
                    ]
                    return node("tr", null, ...cols);
                }
            ));
            const overview = node("table", {"id": "datasets"}, header, rows);

            empty(target);
            target.append(overview);
        }
        // OPTIM: perhaps abort if loaded in the past n miliseconds
        async loadDatasets() {
            const raw = await (await fetch('/api/datasets')).json();
            this.datasets = Object.fromEntries(raw.map(x => [x.id, x]))
        }
        async runQuery(query) {
            await this.loadDatasets();
            if (query["select"] === undefined) {
                const columns = this.datasets[query.dataset].schema.map(x => x.name);
                // always submit it as quoted if it's not all lowercase,
                // TODO: are there quotes in the individual names? can there be?
                // also, columns with all lowercase but with spaces need to be quoted
                // TODO: make this into a robust test harness
                // it would also be good if trailing spaces were ignored upon ingest in loader.go
                query["select"] = columns.map(x => (x.toLowerCase() === x && !x.includes(" ")) ? x : `"${x}"`);
            }
            if (query["limit"] === undefined) {
                query["limit"] = 100; // ARCH: safety mechanism
            }
            const req = await fetch('/api/query', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(query),
            })
            return await req.json();
        }
        async renderTable(data, target) {
            const table = node("table", {"class": "data-view"},
                node("thead", {},
                    node("tr", {}, ...data.schema.map((col) => node("th", {}, col.name)))
                )
            )

            // this works, could only fail if we get zero columns, but that can't happen
            // might be more convenient/explicit if we send nrows from the backend
            // TODO: send this as metadata
            const nrows = data.data[0].length;

            for (let rowNum=0; rowNum < nrows; rowNum++) {
                const row = node("tr", {},
                    ...data.schema.map((val, idx) => {
                        return node("td", {}, data.data[idx][rowNum])
                    })
                )
                table.appendChild(row);
                // ARCH: I think the imperative code below is more readable...
                // const row = document.createElement('tr');
                // for (let colNum = 0; colNum < data.schema.length; colNum++) {
                //     const cell = document.createElement('td');
                //     cell.innerText = data.data[colNum][rowNum];
                //     row.appendChild(cell);
                // }
                // table.appendChild(row);
            }

            empty(target);
            target.appendChild(table);
        }
    }

    const db = new smda();
</script>

</body>
</html>